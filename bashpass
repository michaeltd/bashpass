#!/usr/bin/env bash
#shellcheck shell=bash source=/dev/null disable=SC1008,SC2096,SC2155,SC1090,SC2068,SC2086,SC2141,SC2046,SC2015
#
# bashpass Xdialog/dialog/terminal assisted password management.

# Timeout settings for Xdialog, Xmessage
# xmessage timeout is in seconds...
declare -rx XMTO="30"
declare -rx XDTO="$((XMTO * 1000))" # Xdialog/dialog is in milliseconds

# Xdialog/dialog
declare -rx DIALOG_OK=0 DIALOG_CANCEL=1 DIALOG_HELP=2 \
	DIALOG_EXTRA=3 DIALOG_ITEM_HELP=4 DIALOG_ESC=255 \
	XDIALOG_HIGH_DIALOG_COMPAT=1 XDIALOG_FORCE_AUTOSIZE=0 \
	XDIALOG_INFOBOX_TIMEOUT="${XDTO}" XDIALOG_NO_GMSGS=1

# Signals to trap
declare -rx SIG_NONE=0 SIG_HUP=1 SIG_INT=2 SIG_QUIT=3 SIG_KILL=9 SIG_TERM=15

#link free (S)cript: (D)ir(N)ame, (B)ase(N)ame.
declare -r sdn="$(dirname "$(realpath "${BASH_SOURCE[0]}")")" \
	sbn="$(basename "$(realpath "${BASH_SOURCE[0]}")")"
declare -r dbsd="${sdn}/databases" \
	scsd="${sdn}/sources"

declare cnfd="${XDG_CONFIG_HOME:-${HOME}/.config}"

declare -r bpusage="Usage: ${sbn} [sample.gpg] [yad|zenity|Xdialog|dialog|terminal] [--debug] [--help]"

declare gpgf db bngpgf bndb usrintrfce

# Process optional arguments
while [[ -n "${1}" ]]; do
    case "${1}" in
        *.gpg) gpgf="${1}";;
        yad|zenity|Xdialog|dialog|terminal) readonly usrintrfce="${1}";;
        -d|--debug) set -x;;
        -h|--help) echo -ne "${bpusage}\n" >&2; exit 1;;
        *) echo -ne "Unknown option: ${1}\n${bpusage}\n" >&2; exit 1;;
    esac
    shift
done

# Try to accommodate optional preference...
if [[ "${usrintrfce}" == "yad" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, yad
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "zenity" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, zenity
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "Xdialog" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "dialog" && -x "$(type -P "${usrintrfce}")" ]]; then # Check for dialog
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "terminal" ]]; then # plain ol' terminal
    unset DIALOG
else # -z USERINTRFCE etc
    # ... or pick a default available UI
    if [[ -x "$(type -P yad)" && -n "${DISPLAY}" ]]; then # Check for X, yad
	declare -xr DIALOG="$(type -P yad)"
	readonly usrintrfce="yad"
    elif [[ -x "$(type -P zenity)" && -n "${DISPLAY}" ]]; then # Check for X, zenity
	declare -xr DIALOG="$(type -P zenity)"
	readonly usrintrfce="zenity"
    elif [[ -x "$(type -P Xdialog)" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
	declare -xr DIALOG="$(type -P Xdialog)"
	readonly usrintrfce="Xdialog"
    elif [[ -x "$(type -P dialog)" ]]; then # Check for dialog
	declare -xr DIALOG="$(type -P dialog)"
	readonly usrintrfce="dialog"
    else
	unset DIALOG
	readonly usrintrfce="terminal"
    fi
fi

if [[ -n "${gpgf}" ]]; then
    readonly gpgf="${dbsd}/${gpgf}"
    readonly db="${gpgf%%.gpg}"
    readonly bngpgf="${gpgf/*\/}" bndb="${db/*\/}"
else
    readonly gpgf="${dbsd}/sample.gpg"
    readonly db="${gpgf%%.gpg}"
    readonly bngpgf="${gpgf/*\/}" bndb="${db/*\/}"
fi

# gpg & shred commands (Thanks Dylan)
type -P gpg  &>/dev/null && gpg="$(type -P gpg)"
type -P gpg2 &>/dev/null && gpg="$(type -P gpg2)"
readonly -a gpgc=( "${gpg}" "--batch" "--yes" "--default-recipient-self" "--output" )
type -P shred &> /dev/null && readonly -a shrc=( "shred" "--zero" "--remove" ) || readonly -a shrc=( "rm" "-f" )

# SQLite commands
readonly -a dcm=( "sqlite3" "-list" "${db}" ) \
	 rcm=( "sqlite3" "-line" "${db}" ) \
	 icm=( "sqlite3" "-csv" "${db}" ) \
	 sql3=( "sqlite3" "${db}" )

# Temp files
readonly tf="${dbsd}/.${bndb}.${$}.tf" \
	 mutex="${dbsd}/.${bndb}.mutex"

# Sources to use
readonly -a srcsfs=( 
    "${scsd}/sqlite3.src" 
    "${scsd}/functions.src" 
    "${scsd}/${usrintrfce}.src"
)

for i in ${srcsfs[@]}; do
    source "${i}" || exit $?
done

create() {
    local maxid="$(maxid)" dm em un pw pw1 cm
    "${FUNCNAME[0]}_${usrintrfce}" || return $?
    source "${tf}"
    if [[ "${pw}" != "${pw1}" ]]; then
	die "Password missmatch"
	return $?
    fi
    [[ "${pw}" =~ ^[0-9]+$ ]] && (( pw >= 8 && pw <= 64 )) && pw="$(gpw "${pw}")"
    [[ -z "${pw}" ]] || (( ${#pw} < 8 )) && pw="$(gpw 16)"
    "${sql3[@]}" "$(insert_into "${dm}" "${em}" "${un}" "${pw}" "${cm}")"
    "${rcm[@]}" "$(select_newrecs "${maxid}")" > "${tf}"
    "results_${usrintrfce}"
}

search() {
    local dm rc pw
    "${FUNCNAME[0]}_${usrintrfce}" || return $?
    source "${tf}"
    "${rcm[@]}" "$(select_dm_like "${dm}")" > "${tf}"
    "results_${usrintrfce}"
}

preview(){
    "${FUNCNAME[0]}_${usrintrfce}" || return $?
}

update() {
    local id errlvl pw pw1
    "${FUNCNAME[0]}_${usrintrfce}" || return $?
    source "${tf}"
    if [[ "${pw}" != "${pw1}" ]]; then
	die "Password missmatch"
	return $?
    fi
    [[ "${pw}" =~ ^[0-9]+$ ]] && (( pw >= 8 && pw <= 64 )) && pw="$(gpw "${pw}")"
    [[ -z "${pw}" ]] || (( ${#pw} < 8 )) && pw="$(gpw 16)"
    "${dcm[@]}" "$(update_pw "${pw}" "${id}")"
    "${rcm[@]}" "$(select_id_eq "${id}")" > "${tf}"
    "results_${usrintrfce}"
}

delete() {
    local errlvl id
    "${FUNCNAME[0]}_${usrintrfce}" || return $?
    source "${tf}"
    "${dcm[@]}" "$(delete_id_eq "${id}")"
    "message_${usrintrfce}"
}

importcsv() {
    local maxid csvf errlvl
    maxid="$(maxid)"
    "${FUNCNAME[0]}_${usrintrfce}" || return $?
    source "${tf}"
    "${icm[@]}" "$(importcsv_sql "${csvf}")"
    "${rcm[@]}" "$(select_newrecs "${maxid}")" > "${tf}"
    "results_${usrintrfce}"
}

exportcsv(){
    local csvf errlvl
    "${FUNCNAME[0]}_${usrintrfce}" || return $?
    source "${tf}"
    "${icm[@]}" "$(select_all)" > "${csvf}"
    if [[ -x "$(type -P xdg-open)" ]]; then
    	"$(type -P xdg-open)" "${csvf}"
    elif [[ -x "$(type -P "${VISUAL}")"  ]]; then
    	"$(type -P "${VISUAL}")" "${csvf}"
    elif [[ -x "$(type -P "${EDITOR}")"  ]]; then
    	"$(type -P "${EDITOR}")" "${csvf}"
    else
	"${PAGER}" "${csvf}"
    fi
}

usage() {
    "${FUNCNAME[0]}_${usrintrfce}"
}

bashpass() {
    trap 'do_quit ${SIG_NONE}' "${SIG_NONE}"
    trap 'do_quit ${SIG_HUP}' "${SIG_HUP}"
    trap 'do_quit ${SIG_INT}' "${SIG_INT}"
    trap 'do_quit ${SIG_QUIT}' "${SIG_QUIT}"
    trap 'do_quit ${SIG_KILL}' "${SIG_KILL}"
    trap 'do_quit ${SIG_TERM}' "${SIG_TERM}"
    
    local OFS="${IFS}" errlvl=0 usrinpt=''

    check_prereqs || return $?
    check_mutex || return $?
    check_decrypt || return $?
    read_dbflds || do_quit $? # Have password $db, $tf and $mutex so from now on, instead of exiting, we're do_quit and trap for propper housekeeping.
    check_sql || do_quit $? 

    # Build menus and help messages.
    local -a tui_ops=( "${red}Create${reset}" "${green}Search${reset}" "Preview" "${blue}Update${reset}" "${cyan}Delete${reset}" "${yellow}Import CSV${reset}" "${yellow}Export CSV${reset}" "${magenta}SQLite3${reset}" "${white}Help${reset}" "${dim}Quit${reset}" )
    local -a gui_ops=( "Create" "Search" "Preview" "Update" "Delete" "Import CSV" "Export CSV" "SQLite3" "Help" "Quit" )
    local -a sdesc=( "New entry" "Find account" "Preview all" "Regen password" "Remove entry" "Import a file" "Export a file" "Sqlite3 session" "Help screen" "Exit" )
    local -a desc=( "gather details for a new account." "search records by domain. (empty for all)" "preview existing accounts." "regenerate an existing password." "remove an account." "prompt for csv file to import." "prompt for csv file to export and preview." "start an sqlite session against ${bndb}." "show this message" "terminate this script." )

    local -a tui_menu=( )
    local -a tui_hmsg=( "\n${bpusage[*]}\n\n" )
    local gui_menu=""
    local -a gui_hmsg=( "\n${bpusage[*]}\n\n" )

    for (( x = 0; x < ${#tui_ops[@]}; x++ )); do
	tui_menu+=( "${x}:${tui_ops[x]}" )
	(( ( x + 1 ) % 4 == 0 )) && tui_menu+=( "\n" ) || tui_menu+=( "\t" )
        tui_hmsg+=( "Use ${x}, for ${tui_ops[x]}, which will ${desc[x]}\n" )
        gui_menu+="${gui_ops[x]}|${sdesc[x]}|${desc[x]}|"
        gui_hmsg+=( "Use ${gui_ops[x]}, to ${desc[x]}\n" )
    done

    tui_menu+=( "\nChoose[0-$((${#tui_ops[*]}-1))]:" )
    local tmp_hmsg="\naccounts table format is as follows:\n$( ${dcm[*]} ".schema ${act}")\n\n"
    tui_hmsg+=( "${tmp_hmsg}" )
    gui_hmsg+=( "${tmp_hmsg}" )

    while :; do
	"${FUNCNAME[0]}_${usrintrfce}"
        errlvl=$?
        case "${errlvl}" in
            "0"|"${DIALOG_OK}")
                case "$(cat "${tf}")" in
                    "${gui_ops[0]}"|"0") create ;;
                    "${gui_ops[1]}"|"1") search ;;
                    "${gui_ops[2]}"|"2") preview ;;
                    "${gui_ops[3]}"|"3") update ;;
                    "${gui_ops[4]}"|"4") delete ;;
                    "${gui_ops[5]}"|"5") importcsv ;;
                    "${gui_ops[6]}"|"6") exportcsv ;;
                    "${gui_ops[7]}"|"7") "${sql3[@]}" ;;
                    "${gui_ops[8]}"|"8") usage ;;
                    "${gui_ops[9]}"|"9") exit ;;
                    *) echo -ne "Invalid responce: ${usrinpt}. Choose from 0 to $((${#tui_ops[*]}-1))\n" >&2;;
                esac ;;
            "1"|"${DIALOG_CANCEL}") exit ;;
            [2-4]|"${DIALOG_HELP}"|"${DIALOG_EXTRA}"|"${DIALOG_ITEM_HELP}") usage ;;
            "255"|"${DIALOG_ESC}") exit ;;
        esac
    done
}

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && "${sbn}" "${@}"
