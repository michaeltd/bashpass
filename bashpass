#!/usr/bin/env bash
#shellcheck shell=bash source=/dev/null disable=SC1008,SC2096,SC2155,SC1090,SC2068,SC2086,SC2141,SC2046,SC2015
#
# bashpass Xdialog/dialog/terminal assisted password management.

# Timeout settings for Xdialog, Xmessage
# xmessage timeout is in seconds...
declare -rx XMTO="30"
declare -rx XDTO="$((XMTO * 1000))" # Xdialog/dialog is in milliseconds

# Xdialog/dialog
declare -rx DIALOG_OK=0 DIALOG_CANCEL=1 DIALOG_HELP=2 \
	DIALOG_EXTRA=3 DIALOG_ITEM_HELP=4 DIALOG_ESC=255 \
	XDIALOG_HIGH_DIALOG_COMPAT=1 XDIALOG_FORCE_AUTOSIZE=0 \
	XDIALOG_INFOBOX_TIMEOUT="${XDTO}" XDIALOG_NO_GMSGS=1

# Signals to trap
declare -rx SIG_NONE=0 SIG_HUP=1 SIG_INT=2 SIG_QUIT=3 SIG_KILL=9 SIG_TERM=15

#link free (S)cript: (D)ir(N)ame, (B)ase(N)ame.
declare -r sdn="$(dirname "$(realpath "${BASH_SOURCE[0]}")")" \
	sbn="$(basename "$(realpath "${BASH_SOURCE[0]}")")"
declare -r dbsd="${sdn}/databases" \
	scsd="${sdn}/sources"

declare -r bpusage="Usage: ${sbn} [sample.gpg] [yad|zenity|Xdialog|dialog|terminal] [--debug] [--help]"

declare gpgf db bngpgf bndb usrintrfce

# Process optional arguments
while [[ -n "${1}" ]]; do
    case "${1}" in
        *.gpg) gpgf="${1}";;
        yad|zenity|Xdialog|dialog|terminal) readonly usrintrfce="${1}";;
        -d|--debug) set -x;;
        -h|--help) echo -ne "${bpusage}\n" >&2; exit 1;;
        *) echo -ne "Unknown option: ${1}\n${bpusage}\n" >&2; exit 1;;
    esac
    shift
done

# Try to accommodate optional preference...
if [[ "${usrintrfce}" == "yad" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, yad
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "zenity" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, zenity
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "Xdialog" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "dialog" && -x "$(type -P "${usrintrfce}")" ]]; then # Check for dialog
    declare -xr DIALOG="$(type -P "${usrintrfce}")"
elif [[ "${usrintrfce}" == "terminal" ]]; then # plain ol' terminal
    unset DIALOG
else # -z USERINTRFCE etc
    # ... or pick a default available UI
    if [[ -x "$(type -P yad)" && -n "${DISPLAY}" ]]; then # Check for X, yad
	declare -xr DIALOG="$(type -P yad)" L="0" C="0"
	readonly usrintrfce="yad"
    elif [[ -x "$(type -P zenity)" && -n "${DISPLAY}" ]]; then # Check for X, zenity
	declare -xr DIALOG="$(type -P zenity)" L="0" C="0"
	readonly usrintrfce="zenity"
    elif [[ -x "$(type -P Xdialog)" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
	declare -xr DIALOG="$(type -P Xdialog)" L="0" C="0"
	readonly usrintrfce="Xdialog"
    elif [[ -x "$(type -P dialog)" ]]; then # Check for dialog
	declare -xr DIALOG="$(type -P dialog)" L="0" C="0"
	readonly usrintrfce="dialog"
    else
	unset DIALOG
	readonly usrintrfce="terminal"
    fi
fi

if [[ -n "${gpgf}" ]]; then
    readonly gpgf="${dbsd}/${gpgf}"
    readonly db="${gpgf%%.gpg}"
    readonly bngpgf="${gpgf/*\/}" bndb="${db/*\/}"
else
    readonly gpgf="${dbsd}/sample.gpg"
    readonly db="${gpgf%%.gpg}"
    readonly bngpgf="${gpgf/*\/}" bndb="${db/*\/}"
fi

# table and field names
readonly act="ACCOUNTS" idf="rowid" dmf="DM" emf="EM" pwf="PW" cmf="CM"
# gpg & shred commands
readonly -a gpgc=( "gpg" "--batch" "--yes" "--default-recipient-self" "--output" )
type -P shred &> /dev/null && readonly -a shrc=( "shred" "--zero" "--remove" ) || readonly -a shrc=( "rm" "-f" )

# SQLite
# Custom -init files ensures there will be no functionality breaking ~/.sqliterc surprises.
# We also need to dump stderr into /dev/null to spare users "-- loading resources from ..." msgs.
readonly sql3rc="${dbsd}/sqliterc_"
readonly -a dcm=( "sqlite3" "-init" "${sql3rc}data" "${db}" ) \
	 rcm=( "sqlite3" "-init" "${sql3rc}report" "${db}" ) \
	 icm=( "sqlite3" "-init" "${sql3rc}import" "${db}" ) \
	 sql3=( "sqlite3" "${db}" )
# Temp files
readonly tf="${dbsd}/.${bndb}.${$}.tf" \
	 mutex="${dbsd}/.${bndb}.mutex"

source "${scsd}/functions.src"

[[ "${usrintrfce}" == "yad" ]] && { display_feedback "SOON(tm)!";exit $?; }

source "${scsd}/${usrintrfce}.src"

create() {
    local maxid="$(maxid)" dm em un pw cm

    "${FUNCNAME[0]}_${usrintrfce}" || return $?

    source "${tf}"

    [[ -z "${pw}" ]] && pw="$(gpw "16")"

    "${sql3[@]}" "INSERT INTO ${act} VALUES('${dm//:/\:}', '${em}', '${un}', '${pw}', '${cm}');"
    echo -ne ".mode line\nSELECT rowid AS id,* FROM ${act} WHERE ${idf} > ${maxid};" | "${sql3[@]}" > "${tf}"

    "results_${usrintrfce}"
}

retrieve() {
    local dm rc pw

    "${FUNCNAME[0]}_${usrintrfce}" || return $?

    source "${tf}"

    # Record Set
    2> /dev/null "${rcm[@]}" "SELECT ${idf} AS ID, ${dmf}, ${emf}, ${pwf}, ${cmf} FROM ${act} WHERE ${dmf} LIKE '%${dm}%';" > "${tf}"

    if [[ -n "$(type -P xclip)" ]]; then
        # Record Count
        rc="$(2> /dev/null "${dcm[@]}" "SELECT count(${idf}) FROM ${act} WHERE ${dmf} LIKE '%${dm}%';")"
        if (( rc == 1 )); then
            pw="$(2> /dev/null "${dcm[@]}" "SELECT ${pwf} FROM ${act} WHERE ${dmf} LIKE '%${dm}%';")"
            echo "${pw}" | "xclip" "-r"
        fi
    fi

    "results_${usrintrfce}"
}

update() {
    local id errlvl pw

    "${FUNCNAME[0]}_${usrintrfce}" || return $?

    source "${tf}"

    [[ "${pw}" =~ ^[0-9]+$ ]] && (( pw >= 8 && pw <= 64 )) && pw="$(gpw "${pw}")"
    [[ -z "${pw}" ]] || (( ${#pw} < 8 )) && pw="$(gpw)"
    2> /dev/null "${dcm[@]}" "UPDATE ${act} SET ${pwf} = '${pw}' WHERE ${idf} = '${id}';"
    2> /dev/null "${rcm[@]}" "SELECT ${idf} AS ID,* FROM ${act} WHERE ${idf} = '${id}';" > "${tf}"

    "results_${usrintrfce}"
}

delete() {
    local errlvl id

    "${FUNCNAME[0]}_${usrintrfce}" || return $?

    source "${tf}"

    2> /dev/null "${dcm[@]}" "DELETE FROM ${act} WHERE ${idf} = '${id}';"

    "message_${usrintrfce}"
}

importcsv() {
    local maxid csvf errlvl
    maxid="$(maxid)"

    "${FUNCNAME[0]}_${usrintrfce}" || return $?

    source "${tf}"
    
    "${icm[@]}" ".import ${csvf} ${act}" 2> /dev/null
    errlvl=$?
    if (( errlvl != 0 )); then
        if [[ -n "${DIALOG}" ]]; then
            "${DIALOG}" "--backtitle" "${bngpgf}" "--title" "Error" "--msgbox" "$(cat "${tf}")" "${L}" "${C}"
        fi
        echo "Error: $(cat "${tf}")"
        return "${errlvl}"
    fi
    2> /dev/null "${rcm[@]}" "SELECT ${dmf} AS ID,* FROM ${act} WHERE ${idf} > ${maxid};" > "${tf}"
    if [[ "${DIALOG}" == "$(type -P Xdialog)" ]]; then
        "${DIALOG}" "--backtitle" "${bngpgf}" "--title" "results" "--editbox" "${tf}" "${L}" "${C}" 2> /dev/null
    else
        "${PAGER}" "${tf}"
    fi
}

exportcsv(){
    local csvf errlvl

    "${FUNCNAME[0]}_${usrintrfce}" || return $?

    source "${tf}"
    
    2> /dev/null "${icm[@]}" "select ${idf} AS ID,* from ${act} order by ${idf} ASC;" > "${tf}"

    errlvl=$?
    if (( errlvl != 0 )); then
        if [[ -n "${DIALOG}" ]]; then
            "${DIALOG}" "--backtitle" "${bngpgf}" "--title" "Error" "--msgbox" "$(cat "${tf}")" "${L}" "${C}"
        fi
        echo "Error: $(cat "${tf}")"
        return "${errlvl}"
    fi

    cat "${tf}" > "${csvf}"

    if [[ -x "$(type -P xdg-open)" ]]; then
    	"$(type -P xdg-open)" "${csvf}"
    elif [[ -x "$(type -P "${VISUAL}")"  ]]; then
    	"$(type -P "${VISUAL}")" "${csvf}"
    elif [[ -x "$(type -P "${EDITOR}")"  ]]; then
    	"$(type -P "${EDITOR}")" "${csvf}"
    else
	"${PAGER}" "${csvf}"
    fi
}

usage() {
    "${FUNCNAME[0]}_${usrintrfce}"
}

main() {

    local OFS="${IFS}" errlvl=0 usrinpt=''

    check_prereqs || return $?
    check_mutex || return $?
    check_decrypt || return $?

    # Have password $DB, $tf and $mutex so from now on, instead
    # of exiting, we're do_quit and trap for propper housekeeping.
    check_sql || do_quit $?

    trap 'do_quit ${SIG_NONE}' "${SIG_NONE}"
    trap 'do_quit ${SIG_HUP}' "${SIG_HUP}"
    trap 'do_quit ${SIG_INT}' "${SIG_INT}"
    trap 'do_quit ${SIG_QUIT}' "${SIG_QUIT}"
    trap 'do_quit ${SIG_KILL}' "${SIG_KILL}"
    trap 'do_quit ${SIG_TERM}' "${SIG_TERM}"
    
    # Build menus and help messages.
    local -a tui_ops=( "${red}Create${reset}" "${green}Retrieve${reset}" "${blue}Update${reset}" "${cyan}Delete${reset}" "${yellow}Import CSV${reset}" "${yellow}Export CSV${reset}" "${magenta}SQLite3${reset}" "${white}Help${reset}" "${dim}Quit${reset}" )
    local -a gui_ops=( "Create" "Retrieve" "Update" "Delete" "Import CSV" "Export CSV" "SQLite3" "Help" "Quit" )
    local -a sdesc=( "New entry" "Find account" "Regen password" "Remove entry" "Import a file" "Export a file" "Sqlite3 session" "Help screen" "Exit" )
    local -a desc=( "gather details for a new account." "search records by domain. (empty for all)" "regenerate an existing password." "remove an account." "prompt for csv file to import." "preview a csv file." "start an sqlite session against ${bndb}." "show this message" "terminate this script." )

    local -a tui_menu=( )
    local -a tui_hmsg=( "\n${bpusage[*]}\n\n" )
    local gui_menu=""
    local -a gui_hmsg=( "\n${bpusage[*]}\n\n" )

    for (( x = 0; x < ${#tui_ops[@]}; x++ )); do
	tui_menu+=( "${x}:${tui_ops[x]}" )
	(( ( x + 1 ) % 4 == 0 )) && tui_menu+=( "\n" ) || tui_menu+=( "\t" )
        tui_hmsg+=( "Use ${x}, for ${tui_ops[x]}, which will ${desc[x]}\n" )
        gui_menu+="${gui_ops[x]}|${sdesc[x]}|${desc[x]}|"
        gui_hmsg+=( "Use ${gui_ops[x]}, to ${desc[x]}\n" )
    done

    tui_menu+=( "\nChoose[0-$((${#tui_ops[*]}-1))]:" )
    local tmp_hmsg="\naccounts table format is as follows:\n$(2> /dev/null ${dcm[*]} ".schema ${act}")\n\n"
    tui_hmsg+=( "${tmp_hmsg}" )
    gui_hmsg+=( "${tmp_hmsg}" )

    while :; do
        if [[ "${DIALOG}" =~ dialog$ ]]; then # Xdialog, dialog menu
            OFS="${IFS}" IFS=$'\|'
            "${DIALOG}" "--backtitle" "${bngpgf}" "--title" "dialog" \
			"--item-help" "--cancel-label" "Quit" "--menu" "Menu:" \
			"$L" "$C" ${#gui_ops[*]} ${gui_menu} 2> "${tf}"
            errlvl=$?
            IFS="${OFS}"
	elif [[ "${DIALOG}" =~ zenity$ ]]; then # zenity
	    OFS=$IFS IFS=$'\|'
	    "${DIALOG}" "--height=$H" "--width=$W" "--list" \
			"--title=Select action" "--hide-header" \
			"--column=Option" "--column=Desc" \
			"--column=Description" ${gui_menu} > "${tf}"
            errlvl=$?
            IFS="${OFS}"
        else # Just terminal menu.
            echo -ne " ${tui_menu[*]}"
            read -r usrinpt
            errlvl=$?
            echo "${usrinpt}" > "${tf}"
        fi
        case "${errlvl}" in
            "0"|"${DIALOG_OK}")
                case "$(cat "${tf}")" in
                    "${gui_ops[0]}"|"0") create ;;
                    "${gui_ops[1]}"|"1") retrieve ;;
                    "${gui_ops[2]}"|"2") update ;;
                    "${gui_ops[3]}"|"3") delete ;;
                    "${gui_ops[4]}"|"4") importcsv ;;
                    "${gui_ops[5]}"|"5") exportcsv ;;
                    "${gui_ops[6]}"|"6") 2> /dev/null "${rcm[@]}" ;;
                    "${gui_ops[7]}"|"7") usage ;;
                    "${gui_ops[8]}"|"8") exit ;;
                    *) echo -ne "Invalid responce: ${usrinpt}. Choose from 0 to $((${#tui_ops[*]}-1))\n" >&2;;
                esac ;;
            "1"|"${DIALOG_CANCEL}") exit ;;
            [2-4]|"${DIALOG_HELP}"|"${DIALOG_EXTRA}"|"${DIALOG_ITEM_HELP}") usage ;;
            "255"|"${DIALOG_ESC}") exit ;;
        esac
    done
}

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "${@}"
