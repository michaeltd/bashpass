#!/bin/bash
#
# Pick up right editor syntax highlighting
#shellcheck disable=SC2207,SC2154

func_assigncmds(){
    [[ -r "${sdn}/.${sbn}.rc" ]] && source "${sdn}/.${sbn}.rc" # Source key details
    # export BP_KEY BP_EML
    export GPG_TTY="$(tty)" # Takes care issues when gpg is not so sure where to expect pinentry input from.

    # gpg commands
    type -P gpg  &>/dev/null && gpgc="$(type -P gpg)"
    type -P gpg2 &>/dev/null && gpgc="$(type -P gpg2)"

    if [[ -n "${BP_KEY}" ]]; then
	export gpgec=("${gpgc}" "--trust-model" "always" "-qer" "${BP_KEY}")
    elif [[ -n "${BP_EML}" ]]; then
	export gpgec=("${gpgc}" "--trust-model" "always" "-qcer" "${BP_EML}")
    else
	export gpgec=("${gpgc}" "-qce")
    fi
    export gpgdc=("${gpgc}" "-qd")

    # Shred commands
    type -P shred &> /dev/null && \
	export shrc=( "shred" "--zero" "--remove" ) || \
	    export shrc=( "rm" "-P" "-f" )

    # SQLite commands
    case "${be}" in
	"mem")
	    export dcm=( "sqlite3" "-list" ) \
		   rcm=( "sqlite3" "-line" ) \
		   icm=( "sqlite3" "-csv" ) \
		   ccm=( "sqlite3" "-column" "-header" ) \
		   scm=( "sqlite3" "-separator" " " ) \
		   sl3=( "sqlite3" ) ;;
	"dsk")
	    export dcm=( "sqlite3" "-list" "${rpdb}" ) \
		   rcm=( "sqlite3" "-line" "${rpdb}" ) \
		   icm=( "sqlite3" "-csv" "${rpdb}" ) \
		   ccm=( "sqlite3" "-column" "-header" "${rpdb}" ) \
		   scm=( "sqlite3" "-separator" " " "${rpdb}" ) \
		   sl3=( "sqlite3" "${rpdb}" ) ;;
    esac
}

func_assignvars(){
    # GPG file, db file related vars
    [[ -z "${gpgf}" ]] && export gpgf="sample.${be}.gpg"
    export db="${gpgf//.gpg/}"
    export bngpgf="${gpgf}"
    export bndb="${db}"
    export rpgpgf="${dbsd}/${gpgf}"
    export rpdb="${dbsd}/${db}"
    export fpgpgf="${sdn}/${rpgpgf}"
    export fpdb="${sdn}/${rpdb}"
    # Temp files
    export mutex="${dbsd}/.${bndb}.mtx"
    export tf="${mutex}"
}

func_assignui(){
    # Try to accommodate optional preference...
    # if [[ "${usrintrfce}" == "gtkdialog" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, gtkdialog
    #     declare -rx DIALOG="$(type -P "${usrintrfce}")"
    if [[ "${usrintrfce}" == "yad" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, yad
	export DIALOG="$(type -P "${usrintrfce}")"
    elif [[ "${usrintrfce}" == "zenity" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, zenity
	export DIALOG="$(type -P "${usrintrfce}")"
    elif [[ "${usrintrfce}" == "Xdialog" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
	export DIALOG="$(type -P "${usrintrfce}")"
	# elif [[ "${usrintrfce}" == "gdialog" && -x "$(type -P "${usrintrfce}")" && -n "${DISPLAY}" ]]; then # Check for X, kdialog
	#     export DIALOG="$(type -P "${usrintrfce}")"
	# elif [[ "${usrintrfce}" == "whiptail" && -x "$(type -P "${usrintrfce}")" ]]; then # Check for whiptail
	#     export DIALOG="$(type -P "${usrintrfce}")"
    elif [[ "${usrintrfce}" == "cdialog" && -x "$(type -P "${usrintrfce}")" ]]; then # Check for cdialog
	export DIALOG="$(type -P "${usrintrfce}")"
    elif [[ "${usrintrfce}" == "dialog" && -x "$(type -P "${usrintrfce}")" ]]; then # Check for dialog
	export DIALOG="$(type -P "${usrintrfce}")"
    elif [[ "${usrintrfce}" == "terminal" ]]; then # plain ol' terminal
	unset DIALOG
    else # -z USERINTRFCE etc
	# ... or pick a default available UI
	# if [[ -x "$(type -P gtkdialog)" && -n "${DISPLAY}" ]]; then # Check for X, gtkdialog
	# 	export DIALOG="$(type -P gtkdialog)"
	# 	declare -r usrintrfce="gtkdialog"
	if [[ -x "$(type -P yad)" && -n "${DISPLAY}" ]]; then # Check for X, yad
	    export DIALOG="$(type -P yad)"
	    export usrintrfce="yad"
	elif [[ -x "$(type -P zenity)" && -n "${DISPLAY}" ]]; then # Check for X, zenity
	    export DIALOG="$(type -P zenity)"
	    export usrintrfce="zenity"
	elif [[ -x "$(type -P Xdialog)" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
	    export DIALOG="$(type -P Xdialog)"
	    export usrintrfce="Xdialog"
	    # elif [[ -x "$(type -P gdialog)" && -n "${DISPLAY}" ]]; then # Check for X, kdialog
	    # 	export DIALOG="$(type -P gdialog)"
	    # 	declare -r usrintrfce="gdialog"
	    # elif [[ -x "$(type -P whiptail)" ]]; then # Check for whiptail
	    # 	export DIALOG="$(type -P whiptail)"
	    # 	declare -r usrintrfce="whiptail"
	elif [[ -x "$(type -P cdialog)" ]]; then # Check for cdialog
	    export DIALOG="$(type -P cdialog)"
	    export usrintrfce="cdialog"
	elif [[ -x "$(type -P dialog)" ]]; then # Check for dialog
	    export DIALOG="$(type -P dialog)"
	    export usrintrfce="dialog"
	else
	    unset DIALOG
	    export usrintrfce="terminal"
	fi
    fi
}

func_setup(){
    # setup - prep bashpass
    echo -ne "\n  ${rpgpgf} Not found.\n  Would you like to build it? [y/N]: "
    if [[ "$(read -r r;echo "${r:-n}")" =~ ^[Yy] ]]; then
	# exit on failed creates/encrypts.
	case "${be}" in
	    "mem")
		local sql="$(cat "${sdn}/examples/create.sql")\n.dump\n"
		echo -ne "${sql}" | "${sl3[@]}" | "${gpgec[@]}" > "${rpgpgf}" || return $? ;;
	    "dsk")
		"${sl3[@]}" < "${sdn}/examples/create.sql" || return $?
		"${gpgec[@]}" < "${rpdb}" > "${rpgpgf}" || return $? ;;
	esac
	
    else
	return 1
    fi
}

func_show_err() {
    local -r ttl="${sbn}: Error!" msg="${FUNCNAME[1]}: ${*}"
    if [[ -n "$(type -P notify-send)" && -n "${DISPLAY}" ]]; then
        "$(type -P notify-send)" "-i" "${sdn}/assets/gpa.png" "-c" "notification" "-t" "${XDTO}" "${ttl}" "${msg}"
    elif [[ -n "$(type -P dialog)" && -z "${DISPLAY}" ]]; then
        "$(type -P dialog)" "--title" "${ttl}" "--msgbox" "${msg}" "0" "0"
    else
        echo -ne "${ttl}\n${msg}\n" >&2
    fi
    return 1
}

func_do_quit() {
    case ${be} in
	"mem")
	    ${shrc[@]} "${mutex}"
	    echo "${sbn} gracefull exit..."
	    return "${1:-0}";;
	"dsk")
	    local -ar f2d=( "${rpdb}" "${mutex}" )
	    # Upon successfull encryption ONLY shred files
	    if ! "${gpgec[@]}" < "${rpdb}" > "${rpgpgf}"; then
		func_show_err "Encryption failed or canceled!"
		return "${?}"
	    else
		for i in ${f2d[@]}; do
		    ${shrc[@]} "${i}";
		done
		echo "${sbn} gracefull exit..."
		return "${1:-0}"
	    fi;;
    esac
}

func_check_prereqs(){
    if [[ ! -t 0 ]]; then
        func_show_err "You'll need to run ${0/*\/} in a terminal (or tty)!"
    elif [[ "${BASH_VERSINFO[0]}" -lt "4" ]]; then
        func_show_err "You'll need bash major version no less than 4."
    elif [[ -z "$(type -P sqlite3 2> /dev/null)" ]]; then
        func_show_err "You need SQLite3 installed."
    elif [[ -z "$(type -P gpg 2> /dev/null)" ]] && [[ -z "$(type -P gpg2 2> /dev/null)" ]]; then
        func_show_err "You need GNU Privacy Guard v2 (gnupg) installed."
    fi
}

# No mutex or func_show_err.
func_check_mutex() {
    # local -ar pids=( $(pgrep -U "${USER}" -f "${bngpgf}") )
    # if [[ "${#pids[*]}" -gt "1" ]]; then
    # 	func_show_err "You can only have one instance of ${bngpgf}."
    # fi
    if [[ -f "${mutex}" ]]; then
	func_show_err "You can only have one instance of ${bngpgf}."
    fi
}

# Decrypt .sqlite, setup temp and mutex or func_show_err.
func_check_decrypt() {
    if ! [[ "$(file -b "${rpgpgf}")" =~ ^PGP ]]; then
	func_show_err "${bngpgf}, does not appear to be a valid PGP file."
	return $?
    fi
    case "${be}" in
	"mem")
	    if ! "${gpgdc[@]}" < "${rpgpgf}" &> /dev/null ; then
		func_show_err "${bngpgf} decryption failed."
		return $?
	    else
		touch "${mutex}"
	    fi;;
	"dsk")
	    if ! "${gpgdc[@]}" < "${rpgpgf}" > "${rpdb}"; then
		func_show_err "${bngpgf} decryption failed."
		return $?
	    elif ! [[ "$(file -b "${rpdb}")" =~ ^SQLite ]]; then # We do have an decrypted $db file so we might as well check it's validity.
		func_show_err "${bndb}, does not appear to be a valid SQLite 3.x database file."
		return $?
	    else
		touch "${mutex}"
	    fi;;
    esac
}

# SQL or func_show_err.
func_check_be() {
    if ! "${be}_export" &> /dev/null; then
        func_show_err "Need a working db to function."
    fi
}

# SQL or func_show_err.
func_check_mem() {
    func_check_be
}

# SQL or func_show_err.
func_check_dsk() {
    func_check_be
}

func_read_dbflds(){
    # ADHOC db table fields extractor just for the lolz factor.
    local -a tbls=($(${be}_tables))
    local schm="$(${be}_schema ${tbls[0]})"
    schm="${schm^^}" # sqlite is case insensitive
    local -a brkdwn=(
	"CREATE" "TABLE" "IF" "NOT" "NULL" "DEFAULT"
	"EXISTS" "INTEGER" "REAL" "TEXT" "BLOB" "TEXT"
	"NUMERIC" "NONE" "INT" "INTEGER" "TINYINT" "SMALLINT"
	"MEDIUMINT" "BIGINT" "UNSIGNED" "BIG" "INT2" "INT8"
	"CHARACTER" "VARCHAR" "VARYING" "CHARACTER" "NCHAR" "NATIVE"
	"NVARCHAR" "CLOB" "DOUBLE" "PRECISION" "FLOAT" "NUMERIC"
	"DECIMAL" "BOOLEAN" "DATE" "DATETIME" "100" "256"
	"PRIMARY" "KEY" "(" ")" "," ";" "\""
    )

    for i in ${brkdwn[@]}; do
	schm="${schm//${i}/$' '}"
    done
    local -a arrflds=( ${schm} )
    export idf="rowid" act="${arrflds[0]}" dmf="${arrflds[1]}" emf="${arrflds[2]}" unf="${arrflds[3]}" pwf="${arrflds[4]}" cmf="${arrflds[5]}"
    unset tbls schm brkdwn arrflds
}

func_regex_allow(){
    # Allowable char classes: [:graph:]==[:alnum:][:punct:]
    echo -ne "[:graph:]" 
}

func_regex_forbid(){
    # Returns a regex string with all forbidden chars to check against user input
    # echo -ne "\`\"'|,\$"
    # echo -ne "[=\`=][=\"=][=\'=][=|=][=,=][=\$=]"
    # echo -ne "$'\`'$'\"'$'\''$'|'$','$'\$'$'\'$' '"
    echo -ne "\ \`\$|,\"'"
}

func_chkinpt(){
    # Returns true (0) on match false (1) otherwise
    [[ "${1}" =~ [$(func_regex_forbid)] ]]
}

func_chkpwd(){
    local pw="${1:-NULL}" pw1="${2:-NULL}"
    [[ "${pw}" != "${pw1}" ]]
}

# Generate PassWord
func_gpw() {
    local pw="$(
        LC_ALL=C tr -dc [$(func_regex_allow)] < /dev/urandom | \
		 tr -d "$(func_regex_forbid)" | \
		 dd ibs=1 obs=1 count="${1:-64}" 2>/dev/null)"
    echo "${pw//\\//}"
}

# Build Row Lines (for (X)dialog check/radio lists)
func_brl() {
    local IFS=$'\n'
    local -a rs=( $(${be}_runcustomsql "${1:-$(${be}_brl_sql)}") )
    for i in ${rs[@]}; do
	local IFS=$'\|'
	local -a rec=( ${i[@]} )
	local rl+="${rec[0]} ${rec[1]//\ /_}|${rec[2]//\ /_}|${rec[3]//\ /_}|${rec[4]//\ /_} off\n"
    done
    [[ -n "${rl[*]}" ]] && echo -ne "${rl[*]}" || echo -ne "-1 No|Records|Found OFF"
}

# func_brlzen(){
#     echo "$("${sl3[@]}" "$(${be}_brl)")"
# }
