#!/bin/bash
#
# Pick up right editor syntax highlighting
#shellcheck disable=SC2207,SC2154

do_quit() {
    # VACUUM on an sqlite db will safely delete erased records as per https://www.sqlite.org/lang_vacuum.html
    "${sql3[@]}" "VACUUM;"
    # Upon successfull encryption ONLY shred files
    "${gpgc[@]}" "${gpgf}" "--encrypt" "${db}" && "${shrc[@]}" {"${db}","${tf}","${mutex}"}
    read -rp "Return to continue ... "
    exit "${1:-0}"
}

display_feedback() {
    local -r msg="${*}"
    local -r ttl="${sbn}: Error!"
    if [[ -n "$(type -P notify-send)" && -n "${DISPLAY}" ]]; then
        "$(type -P notify-send)" "-i" "${sdn}/assets/gpa.png" "-c" "notification" "-t" "${XDTO}" "${ttl}" "${msg}"
    elif [[ -n "$(type -P Xdialog)" && -n "${DISPLAY}" ]]; then
        "$(type -P Xdialog)" "--title" "${ttl}" "--msgbox" "${msg}" "0" "0"
    elif [[ -n "$(type -P xmessage)" && -n "${DISPLAY}" ]]; then
        "$(type -P xmessage)" "-nearmouse" "-timeout" "${XMTO}" "${ttl} ${msg}"
    elif [[ -n "$(type -P dialog)" && -z "${DISPLAY}" ]]; then
        "$(type -P dialog)" "--title" "${ttl}" "--msgbox" "${msg}" "0" "0"
    else
        echo -ne "${ttl}\n${msg}\n" >&2
    fi
    return 1
}

check_prereqs(){
    if [[ ! -t 0 ]]; then
        display_feedback "You'll need to run ${0/*\/} in a terminal (or tty)!"
    elif [[ "${BASH_VERSINFO[0]}" -lt "4" ]]; then
        display_feedback "You'll need bash major version no less than 4."
    elif [[ -z "$(type -P sqlite3 2> /dev/null)" ]]; then
        display_feedback "You need SQLite3 installed."
    elif [[ -z "$(type -P gpg 2> /dev/null)" ]]; then
        display_feedback "You need GNU Privacy Guard v2 (gnupg) installed."
    fi
}

# No mutex or die.
check_mutex() {
    if [[ -f "${mutex}" ]]; then
	display_feedback "You can only have one instance of ${bngpgf}."
    fi
    # local -ar pids=( $(pgrep -U "${USER}" -f "${bngpgf}") )
    # if [[ "${#pids[*]}" -gt "1" ]]; then
    # 	display_feedback "You can only have one instance of ${bngpgf}."
    # fi
}

# Decrypt .sqlite, setup trap and mutex or die.
check_decrypt() {
    if ! [[ "$(file -b "${gpgf}")" =~ ^PGP ]]; then
        display_feedback "${bngpgf}, does not appear to be a valid PGP file."
        return $?
    fi
    if ! "${gpgc[@]}" "${db}" "--decrypt" "${gpgf}"; then
        display_feedback "Decryption failed."
        return $?
    else
	# We do have an decrypted $db file so we might as well check it's validity.
        if ! [[ "$(file -b "${db}")" =~ ^SQLite ]]; then
            display_feedback "${bndb}, does not appear to be a valid SQLite 3.x database file."
            return $?
        fi
        touch "${mutex}"
        touch "${tf}"
    fi
}

# SQL or die.
check_sql() {
    if ! "${dcm[@]}" "SELECT * FROM ${act} ORDER BY ${idf} ASC;" &> /dev/null; then
        display_feedback "Need a working db to function."
    fi
}

# Generate PassWord
gpw() {
    LC_ALL=C tr -dc "[:graph:]" < /dev/urandom | \
	tr -d "[=\"=][=\'=][=\|=][=\,=]" | \
	dd ibs=1 obs=1 count="${1:-64}" 2>/dev/null
    echo
}

# RowID'S
rids() {
    "${dcm[@]}" "SELECT ${idf} FROM ${act} ORDER BY ${idf} ASC;"
}

# -.-
maxid() {
    #shellcheck disable=SC2155
    local maxid="$("${dcm[@]}" "SELECT MAX(${idf}) FROM ${act};")"
    echo "${maxid:-0}" # check null values
}

# Row count
rcount() {
    "${dcm[@]}" "SELECT COUNT(${idf}) FROM ${act};"
}

# Build Row Lines (for (X)dialog check/radio lists)
brl() {
    local dm em un rl
    for i in $(rids); do
        dm=$("${dcm[@]}" "SELECT ${dmf} FROM ${act} WHERE ${idf} = '${i}';"|sed 's/ /-/g')
        em=$("${dcm[@]}" "SELECT ${emf} FROM ${act} WHERE ${idf} = '${i}';"|sed 's/ /-/g')
        un=$("${dcm[@]}" "SELECT ${unf} FROM ${act} WHERE ${idf} = '${i}';"|sed 's/ /-/g')
        rl+="${i} ${dm:-NULL}_${em:-NULL}_${un:-NULL} off "
    done
    echo "${rl[@]}"
}

brlzen(){
    echo "$(sqlite3 -separator " " ${db} "SELECT 'FALSE' AS STATE, ${idf} AS ID, ${dmf} AS DM, ${emf} AS EM, ${unf} AS UN FROM ${act} ORDER BY ${idf} asc;")"
}
